#!/usr/bin/env python3
import sys
import argparse
import tempfile
import os
import numpy as np
import json
from gambit.sigs import load_signatures, dump_signatures, AnnotatedSignatures, SignatureList
from ete3 import Tree

#!/usr/bin/env python3
"""
Given a gambit database and an assembly, create a phylogenetic tree of the closest genomes
to place the assembly in context. Additionally provide distance information about the other genomes.

Query an assembly against a gambit database
- output in archive format  (json, 10 closest matches)
Given a list of keys (10 closest), create a signatures file
Create a signatures file for the query genome
Merge the signatures files
Create a tree from the signatures file
Output - list of genomes and a distance
output - phylogenetic tree
"""

# Parse command line arguments
parser = argparse.ArgumentParser(
    description='Place a genome in context from the database',
    usage='gambit-context [options]',
    formatter_class=argparse.ArgumentDefaultsHelpFormatter)

# Required input files
parser.add_argument('gambit_database_directory', help='/path/to/gambit/database', type=str)
parser.add_argument('gambit_signatures_filename', help='/path/to/gambit/database/signatures_file.gs', type=str)
parser.add_argument('assembly_filenames', help='Assemblies in FASTA format, can be gzipped', type=str, nargs='+')

parser.add_argument('--signatures_output_filename', '-s', help='Output filename for genome signatures', default='merged_database.gs', type=str)
parser.add_argument('--tree_output_filename', '-t', help='Output filename for tree (newick format)', default='genome_tree.nwk', type=str)
parser.add_argument('--tree_image_output_filename', '-i', help='Output filename for tree image (png format)', default='genome_tree.png', type=str)
parser.add_argument('--cpus', '-p', help='Number of cpus to use', type=int, default=1)
parser.add_argument('--verbose', '-v', action='store_true', help='Turn on verbose output', default=False)

options = parser.parse_args()

# List to store the closest genome accessions
close_accessions = []

# Create a temporary directory to store intermediate files
with tempfile.TemporaryDirectory() as temp_dir:
    # Path to the output file from the gambit command
    gambit_output = os.path.join(temp_dir, 'gambit_output.json')

    # Run the gambit command to query the assembly against the gambit database
    os.system("gambit -d " + str(options.gambit_database_directory) + " query -o " + str(gambit_output) + " -f  archive " + str(' '.join(options.assembly_filenames)))

    # Read the output file and extract the closest genomes
    with open(gambit_output, 'r') as f:
        data = json.load(f)
        closest_genomes_json = data['items'][0]['closest_genomes']
        close_accessions = [g['genome']['key'] for g in closest_genomes_json]

        if options.verbose:
            # Print the closest genomes and their distances
            print("Accession\tGambit_distance")
            for genome in closest_genomes_json:
                print(genome['genome']['key'] + "\t" + "{:.6f}".format(genome['distance']))

    # Create temporary files for genome signatures
    with tempfile.NamedTemporaryFile(suffix='.gs', delete=False) as input_genome_signatures_file, \
            tempfile.NamedTemporaryFile(suffix='.gs', delete=False) as filtered_genome_signatures_file:

        input_genome_signatures = input_genome_signatures_file.name
        filtered_genome_signatures = filtered_genome_signatures_file.name

        # Create signatures file for the query genome
        os.system("gambit signatures create -k 11 -p ATGAC -o " + input_genome_signatures + " " + str(' '.join(options.assembly_filenames)))

        # Filter the signatures database to only include the context genomes
        with load_signatures(options.gambit_signatures_filename) as src:
            in_gidxs = np.flatnonzero(np.in1d(src.ids, close_accessions))
            filtered_src_ids = src.ids[in_gidxs]
            filtered_src = src[in_gidxs]
            out_sigs = AnnotatedSignatures(filtered_src, filtered_src_ids, src.meta)

            dump_signatures(filtered_genome_signatures, out_sigs)

        # Merge the two signatures files, including the input genomes and the context genomes from the database
        with load_signatures(filtered_genome_signatures) as main_sig, load_signatures(input_genome_signatures) as patch_sig:
            # Merge the two signatures files
            merged_src_ids = np.concatenate((main_sig.ids, patch_sig.ids))
            merged_src = SignatureList(main_sig)
            merged_src.extend(patch_sig)
            out_sigs = AnnotatedSignatures(merged_src, merged_src_ids, main_sig.meta)

            dump_signatures(options.signatures_output_filename, out_sigs)

        # Create a phylogenetic tree from the merged signatures file
        os.system("gambit tree -s " + options.signatures_output_filename + " -c " + str(options.cpus) + " > " + options.tree_output_filename)

        # Remove the temporary files
        os.remove(input_genome_signatures)
        os.remove(filtered_genome_signatures)

# Create a phylogenetic tree image
# python -m ete3 view -t genome_tree.nwk --image-output genome_tree.png --dpi 300 --width 800
# Read the newick file
tree = Tree(options.tree_output_filename)
# Midpoint root the tree
tree.set_outgroup(tree.get_midpoint_outgroup())
# Order the tree in descending order
tree.ladderize()

# right align the taxon names
for n in tree.traverse():
    n.img_style["size"] = 0
    n.img_style["fgcolor"] = "black"
    n.img_style["vt_line_color"] = "black"
    n.img_style["hz_line_color"] = "black"
    n.img_style["hz_line_width"] = 1
    n.img_style["vt_line_width"] = 1
    n.img_style["vt_line_type"] = 0
    n.img_style["hz_line_type"] = 0
    n.img_style["vt_line_color"] = "black"
    n.img_style["hz_line_color"] = "black"
    n.img_style["hz_line_width"] = 1
    n.img_style["vt_line_width"] = 1
    n.img_style["vt_line_type"] = 0
    n.img_style["hz_line_type"] = 0
    n.img_style["size"] = 0
    n.img_style["shape"] = "square"
    n.img_style["fgcolor"] = "black"
    n.img_style["bgcolor"] = "white"
    n.img_style["vt_line_color"] = "black"
    n.img_style["hz_line_color"] = "black"
    n.img_style["hz_line_width"] = 1
    n.img_style["vt_line_width"] = 1
    n.img_style["vt_line_type"] = 0
    n.img_style["hz_line_type"] = 0
    n.img_style["vt_line_color"] = "black"
    n.img_style["hz_line_color"] = "black"
    n.img_style["hz_line_width"] = 1
    n.img_style["vt_line_width"] = 1
    n.img_style["vt_line_type"] = 0
    n.img_style["hz_line_type"] = 0
    n.img_style["size"] = 0
    n.img_style["shape"] = "square"
    n.img_style["fgcolor"] = "black"
    n.img_style["bgcolor"] = "white"

    if n.is_leaf():
        n.img_style["size"] = 0
        n.img_style["shape"] = "square"
        n.img_style["fgcolor"] = "black"
        n.img_style["bgcolor"] = "white"
        n.img_style["vt_line_color"] = "black"
        n.img_style["hz_line_color"] = "black"
        n.img_style["hz_line_width"] = 1
        n.img_style["vt_line_width"] = 1
        n.img_style["vt_line_type"] = 0
        n.img_style["hz_line_type"] = 0

# Output the image as a png
tree.render(options.tree_image_output_filename, w=800, units="px", dpi=300)
